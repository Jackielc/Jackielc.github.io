<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jackcao</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 25 Dec 2018 09:37:55 +0800</pubDate>
    <lastBuildDate>Tue, 25 Dec 2018 09:37:55 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>扑尔敏</title>
        <description>&lt;h3 id=&quot;扑尔敏&quot;&gt;扑尔敏&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;马来酸氯苯那敏，白色片剂，又名扑尔敏，适用于皮肤过敏症。服用后会存在嗜睡，困乏等不良反应。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/in-post-2018/post-puermin.jpg&quot; alt=&quot;post-puermin&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;十二月的上海&quot;&gt;十二月的上海&lt;/h3&gt;

&lt;p&gt;上海今年的冬天让人感到恶心，已经快一个月没有正正经经的晴过天了，小雨和雾霾已成标配，潮湿的空气让人难受，长期处于这种环境下，没有几个人心情会好。&lt;/p&gt;

&lt;p&gt;每天下班回到家到处都是湿哒哒的，已经不敢开窗户了，虽然空调有除湿功能，但好像毫无作用，开加热倒是还有些效果。&lt;/p&gt;

&lt;h3 id=&quot;过敏&quot;&gt;过敏&lt;/h3&gt;

&lt;p&gt;上周开始感到浑身发痒，起初并不在意，这几天竟一直痒，昨天去问了问医生，说是 &lt;strong&gt;&lt;em&gt;“最近空气潮湿，皮肤过敏的人很多。买点扑尔敏吃就可以了”&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;皮肤过敏？好像是第一次发生在我身上。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘侬要什么药呀。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘阿姨，扑尔敏有吗？’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘扑尔敏有的呀，小伙子侬哪里不舒服呀？’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘有点过敏。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘过敏了呀？’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘嗯。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘我给侬找找呴，侬等下。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘嗯，好的。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘找到了，侬先去缴费，再来拿药。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘嗯。’&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;晚上买完药回到家已经八点多，就着冰红茶，取出一粒喝了下去。然后打开电脑帮朋友改改简历，此时已经发困，想起昨天同学过生日玩到今天凌晨三点多，也就并没有在意。&lt;/p&gt;

&lt;p&gt;十点，关上电脑，昏昏沉沉的睡了下去，一晚上痒醒了好几次。&lt;/p&gt;

&lt;p&gt;今天早上八点才起床，不过还是很困，当时只是觉得可能是前天睡太晚。&lt;/p&gt;

&lt;p&gt;收拾完坐电梯下楼，睡眼惺忪的我感觉到今天的天气好像还不错。&lt;/p&gt;

&lt;p&gt;在公司楼下的全家买了点早餐，打着哈欠顺着早餐又服下了一片。回到楼上，发现座位桌子上又多了一大袋东西，不出意料又是公司发的化妆品和洗发品，大部分都是便宜的日本货和韩国货，但是有时也会送一些欧美大牌但是销量不好的东西。这些花花绿绿的东西，懒得带回去。
&lt;img src=&quot;/img/in-post/in-post-2018/post-gifts.png&quot; alt=&quot;post-gifts&quot; /&gt;&lt;/p&gt;

&lt;p&gt;十点多左右开始困得不行了，很纳闷，为啥会那么困呢？我想起了扑尔敏，然后去百度，发现原来是这个家伙在搞鬼。&lt;/p&gt;

&lt;p&gt;强打精神也阻止不了药效的发挥，我只能戴上颈枕，顺其自然地睡一觉，还好今天没有bug也没有新功能也没有任何要改动的地方，也跟所有人说了不要打扰。&lt;/p&gt;

&lt;p&gt;这一觉睡到了一点半，醒来睁开眼睛，又是那种被全世界抛弃的感觉。&lt;/p&gt;

</description>
        <pubDate>Mon, 24 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/24/%E6%89%91%E5%B0%94%E6%95%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/24/%E6%89%91%E5%B0%94%E6%95%8F/</guid>
        
        <category>生活</category>
        
        <category>生病</category>
        
        <category>记事</category>
        
        
      </item>
    
      <item>
        <title>alloc和init</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;最近在读Runtime的源代码，有很多疑问和心得，特此记录&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;h3 id=&quot;nsobject&quot;&gt;NSObject&lt;/h3&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;中，除去一些基本的数据类型之外，几乎所有的类都是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;的子类。继承&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;的子类都可以访问&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;的接口，并赋予其&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;对象的基本行为和能力。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The root class of most Objective-C class hierarchies, from which subclasses inherit a basic interface to the runtime system and the ability to behave as Objective-C objects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;alloc-和-init&quot;&gt;alloc 和 init&lt;/h3&gt;
&lt;p&gt;初始化一个继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;的对象时我们一般都会这样做。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;SomeClass *instance = [[SomeClass alloc]init];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;有什么用？&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;解释称&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;alloc&lt;/strong&gt;: Returns a new instance of the receiving class. // 返回该类的一个新的实例对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;init&lt;/strong&gt;: Implemented by subclasses to initialize a new object (the receiver) immediately after memory for it has been allocated. //由子类实现，以便在为新对象(接收方)分配内存之后立即初始化该对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是为什么要这样做呢？其中的细节是什么样子的？事实真的是这样吗？虽说&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt;是闭源的，还好&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;开源了&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;，让我们可以一探究竟。&lt;/p&gt;

&lt;h3 id=&quot;objective-c-runtime&quot;&gt;Objective-C Runtime&lt;/h3&gt;
&lt;p&gt;什么是&lt;a href=&quot;https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc&quot;&gt;Runtime&lt;/a&gt;？&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;介绍的很清楚&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Describes the macOS Objective-C runtime library support functions and data structures.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Objective-C runtime is a runtime library that provides support for the dynamic properties of the Objective-C language, and as such is linked to by all Objective-C apps. Objective-C runtime library support functions are implemented in the shared library found at /usr/lib/libobjc.A.dylib.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;一句话总结：&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;面向对象和动态机制的基石。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;下载和编译runtime&quot;&gt;下载和编译Runtime&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;目前是开源的，开发者可以自由下载。进入&lt;a href=&quot;https://opensource.apple.com/source/&quot;&gt;Apple Open Source&lt;/a&gt;，按下&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd&lt;/code&gt;+&lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;并输入&lt;code class=&quot;highlighter-rouge&quot;&gt;objc4&lt;/code&gt;，然后定位并点击进入目录，will see it
&lt;img src=&quot;/img/in-post/in-post-2018/post-runtime-files.png&quot; alt=&quot;post-runtime-files&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尾数越大的表明版本越新，不过我在这里使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;objc4-723&lt;/code&gt;版本，虽然Apple有压缩包可以&lt;a href=&quot;https://opensource.apple.com/tarballs/objc4/&quot;&gt;下载&lt;/a&gt;，但是下载的源代码直接进行
编译是不通过的，编译的整个过程很麻烦，需要补充很多文件，如果图省事可以直接去Github上寻找已经可以编译的版本。&lt;/p&gt;

&lt;h3 id=&quot;探究调用过程&quot;&gt;探究调用过程&lt;/h3&gt;
&lt;p&gt;新建名为&lt;code class=&quot;highlighter-rouge&quot;&gt;SomeClass&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;子类，在&lt;code class=&quot;highlighter-rouge&quot;&gt;main.m&lt;/code&gt;中初始化，打上断点然后build&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;int main(int argc, const char * argv[]) {
    @autoreleasepool {
        SomeClass *instance = [[SomeClass alloc]init]; //break point
        NSLog(@&quot;%@&quot;,instance);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时进入&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject.mm&lt;/code&gt;文件中，我们会看到&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;的实现,&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;只是简单的调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;_objc_rootAlloc&lt;/code&gt;函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (id)alloc {
    return _objc_rootAlloc(self);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_objc_rootAlloc&lt;/code&gt;的实现为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// Base class implementation of +alloc. cls is not nil.
// Calls [cls allocWithZone:nil].
id
_objc_rootAlloc(Class cls)
{
    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点是&lt;code class=&quot;highlighter-rouge&quot;&gt;callAlloc&lt;/code&gt;的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// Call [cls alloc] or [cls allocWithZone:nil], with appropriate 
// shortcutting optimizations.
static ALWAYS_INLINE id
callAlloc(Class cls, bool checkNil, bool allocWithZone=false)
{
    if (slowpath(checkNil &amp;amp;&amp;amp; !cls)) return nil;

#if __OBJC2__
    if (fastpath(!cls-&amp;gt;ISA()-&amp;gt;hasCustomAWZ())) {
        // No alloc/allocWithZone implementation. Go straight to the allocator.
        // fixme store hasCustomAWZ in the non-meta class and 
        // add it to canAllocFast's summary
        if (fastpath(cls-&amp;gt;canAllocFast())) {
            // No ctors, raw isa, etc. Go straight to the metal.
            bool dtor = cls-&amp;gt;hasCxxDtor();
            id obj = (id)calloc(1, cls-&amp;gt;bits.fastInstanceSize());
            if (slowpath(!obj)) return callBadAllocHandler(cls);
            obj-&amp;gt;initInstanceIsa(cls, dtor);
            return obj;
        }
        else {
            // Has ctor or raw isa or something. Use the slower path.
            id obj = class_createInstance(cls, 0);
            if (slowpath(!obj)) return callBadAllocHandler(cls);
            return obj;
        }
    }
#endif

    // No shortcuts available.
    if (allocWithZone) return [cls allocWithZone:nil];
    return [cls alloc];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;callAlloc&lt;/code&gt;方法中有三个参数,&lt;code class=&quot;highlighter-rouge&quot;&gt;cls&lt;/code&gt;为当前的调用类，&lt;code class=&quot;highlighter-rouge&quot;&gt;checkNil&lt;/code&gt;为判空，&lt;code class=&quot;highlighter-rouge&quot;&gt;allocWithZone&lt;/code&gt;表示是否实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;allocWithZone&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;=false&lt;/code&gt;代表默认是没有实现的。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSZone&lt;/code&gt;其实已经在Objective-C中被弃用了，为什么会被保留下来，Apple解释称&lt;code class=&quot;highlighter-rouge&quot;&gt;allocWithZone&lt;/code&gt;的存在是由于历史原因才会被保留下来。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (slowpath(checkNil &amp;amp;&amp;amp; !cls)) return nil;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;进入方法内部，会发现一个判空的宏，叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;slowpath&lt;/code&gt;，计算机术语叫做慢路径，表示条件很可能为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;，让编译器做优化，以此提升性能，虽然是一个很小的优化，但是对于alloc这样在应用中会被大量调用的方法来说，这样做还是很值得的。&lt;/p&gt;

&lt;p&gt;然后是条件编译&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if __OBJC2__

   ...

#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;表示当前的&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;版本为2.0才能进入，一般情况下在我们的开发环境中&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;的版本都是2.0。
条件成立，然后进入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fastpath(!cls-&amp;gt;ISA()-&amp;gt;hasCustomAWZ())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fastpath&lt;/code&gt;为快路径，表示结果大概率为真，&lt;code class=&quot;highlighter-rouge&quot;&gt;cls-&amp;gt;ISA()-&amp;gt;hasCustomAWZ()&lt;/code&gt;表示当前类是否存在&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;allocWithZone&lt;/code&gt;的实现，根据其中的注释，这个判断操作返回的结果大概率为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;紧接着进入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (fastpath(cls-&amp;gt;canAllocFast()))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从字面意思来讲，这个方法应该是判断当前类是否可以快速地进行&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;操作，不过当我进入&lt;code class=&quot;highlighter-rouge&quot;&gt;canAllocFast&lt;/code&gt;的方法内部时，我发现这个方法永远返回的是&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;，所以最后会进入&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;分支&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Has ctor or raw isa or something. Use the slower path.
    id obj = class_createInstance(cls, 0);
    if (slowpath(!obj)) return callBadAllocHandler(cls);
    return obj;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;开始创建新的实例，(&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针先放在这里，以后再去探究。)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/***********************************************************************
* class_createInstance
* fixme
* Locking: none
**********************************************************************/
id 
class_createInstance(Class cls, size_t extraBytes)
{
    //---
    return _class_createInstanceFromZone(cls, extraBytes, nil);
}

static __attribute__((always_inline)) 
id
_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, 
                              bool cxxConstruct = true, 
                              size_t *outAllocatedSize = nil)
{
    if (!cls) return nil;

    assert(cls-&amp;gt;isRealized());

    // Read class's info bits all at once for performance
    bool hasCxxCtor = cls-&amp;gt;hasCxxCtor();
    bool hasCxxDtor = cls-&amp;gt;hasCxxDtor();
    bool fast = cls-&amp;gt;canAllocNonpointer();

    size_t size = cls-&amp;gt;instanceSize(extraBytes);
    if (outAllocatedSize) *outAllocatedSize = size;

    id obj;
    if (!zone  &amp;amp;&amp;amp;  fast) {
        obj = (id)calloc(1, size);
        if (!obj) return nil;
        obj-&amp;gt;initInstanceIsa(cls, hasCxxDtor);
    } 
    else {
        if (zone) {
            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);
        } else {
            obj = (id)calloc(1, size);
        }
        if (!obj) return nil;

        // Use raw pointer isa on the assumption that they might be 
        // doing something weird with the zone or RR.
        obj-&amp;gt;initIsa(cls);
    }

    if (cxxConstruct &amp;amp;&amp;amp; hasCxxCtor) {
        obj = _objc_constructOrFree(obj, cls);
    }

    return obj;
}、

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;创建实例和分配空间的操作都在&lt;code class=&quot;highlighter-rouge&quot;&gt;_class_createInstanceFromZone&lt;/code&gt;方法中进行。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if (!cls) return nil;

    assert(cls-&amp;gt;isRealized()); // 防止并发实现

    // Read class's info bits all at once for performance
    bool hasCxxCtor = cls-&amp;gt;hasCxxCtor(); // 是否有C++构造函数
    bool hasCxxDtor = cls-&amp;gt;hasCxxDtor(); // 是否有C++析构函数
    bool fast = cls-&amp;gt;canAllocNonpointer(); //是否需要初始化isa指针。如果在64位机器上运行，会返回true

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后获取对象大小&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cls-&amp;gt;instanceSize(extraBytes); // extraBytes为额外需要的bytes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceSize&lt;/code&gt;的内部实现会进行字节对齐，而且会对小于16&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;的对象，强制给予16&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;。因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;称&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;CF(CoreFoundation) requires all objects be at least 16 bytes.&lt;/em&gt;&lt;/strong&gt; //CoreFoundation 要求所有的对象大小至少为16字节&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们不需要&lt;code class=&quot;highlighter-rouge&quot;&gt;NSZone&lt;/code&gt;而且&lt;code class=&quot;highlighter-rouge&quot;&gt;fast&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;ture&lt;/code&gt;，所以我们会直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;calloc&lt;/code&gt;进行内存分配,并且初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (!zone  &amp;amp;&amp;amp;  fast) {
    obj = (id)calloc(1, size);
    if (!obj) return nil;
    obj-&amp;gt;initInstanceIsa(cls, hasCxxDtor);
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;值得一提的是在&lt;code class=&quot;highlighter-rouge&quot;&gt;initInstanceIsa&lt;/code&gt;方法中会判断当前类是否支持&lt;code class=&quot;highlighter-rouge&quot;&gt;TAGGED POINTERS&lt;/code&gt;(除去一些外部因素，64位机器都支持)：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Tagged Pointer&lt;/em&gt;&lt;/strong&gt; 是Apple在2013年推出的技术。因为在64位系统架构下，指针变量由32位增加到64位，这意味着对于一些对象(&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNumber&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDate&lt;/code&gt;等)来说可能会存在存储浪费的问题，所以Apple决定将一些比较小的数据直接存储在指针变量中，这些指针变量就叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;TAGGED POINTERS&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;Tagged Pointer&lt;/em&gt;&lt;/strong&gt; 的值不再是地址，而是真正的值。但是它并不是一个对象，而是一个变量，而且内存不在堆中。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;inline void 
objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) 
{ 
    assert(!isTaggedPointer()); //不允许当前对象是‘Tagged Pointer’，因为TaggedPointer是一个伪对象不允许拥有isa指针
    
    if (!nonpointer) { //是否开启TAGGED POINTERS
        isa.cls = cls;
    } else {
        assert(!DisableNonpointerIsa); //xcode中禁用了‘TAGGED POINTERS’环境变量
        assert(!cls-&amp;gt;instancesRequireRawIsa());// 实例不需要isa指针

        isa_t newisa(0);

#if SUPPORT_INDEXED_ISA
        assert(cls-&amp;gt;classArrayIndex() &amp;gt; 0);
        newisa.bits = ISA_INDEX_MAGIC_VALUE;
        // isa.magic is part of ISA_MAGIC_VALUE
        // isa.nonpointer is part of ISA_MAGIC_VALUE
        newisa.has_cxx_dtor = hasCxxDtor;
        newisa.indexcls = (uintptr_t)cls-&amp;gt;classArrayIndex();
#else
        newisa.bits = ISA_MAGIC_VALUE; //赋值给isa联合体
        // isa.magic is part of ISA_MAGIC_VALUE
        // isa.nonpointer is part of ISA_MAGIC_VALUE
        newisa.has_cxx_dtor = hasCxxDtor;
        newisa.shiftcls = (uintptr_t)cls &amp;gt;&amp;gt; 3;
#endif

        // This write must be performed in a single store in some cases
        // (for example when realizing a class because other threads
        // may simultaneously try to use the class).
        // fixme use atomics here to guarantee single-store and to
        // guarantee memory order w.r.t. the class index table
        // ...but not too atomic because we don't want to hurt instantiation
        isa = newisa;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果分配内存失败则会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;callBadAllocHandler&lt;/code&gt;函数并抛出异常。如果当前类有自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;allocWithZone&lt;/code&gt;的话就会去调用分支&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;    if (allocWithZone) {
        return [cls allocWithZone:nil];
    }
    return [cls alloc]; // 如果所有条件都不满足，那就开启死循环
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此，一个对象就成功地分配到了内存。然后就会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;
- (id)init {
    return _objc_rootInit(self);
}

id
_objc_rootInit(id obj)
{
    // In practice, it will be hard to rely on this function.
    // Many classes do not properly chain -init calls.
    return obj;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是的，系统直接给我们返回了对象本身，什么都没做，这时候我们就要思考这个函数存在的意义了。&lt;/p&gt;

&lt;h3 id=&quot;init函数&quot;&gt;init函数&lt;/h3&gt;
&lt;p&gt;我们回头再来看&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;说过的话&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;init&lt;/em&gt;&lt;/strong&gt;: Implemented by subclasses to initialize a new object (the receiver) immediately after memory for it has been allocated. //由子类实现，以便在为新对象(接收方)分配内存之后立即初始化该对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;的源代码我们可以知道，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数中并没有做任何操作，它只是返回了&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;。其实&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;在开发文档中说的很明白，&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数是留给子类重载的，子类可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;里做一些初始化的操作，比如初始化一些变量、对象…来给实例一些默认的行为和能力。因为子类可以自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数的实现，所以在某些情况下我们也可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数中返回一个替代的实例，也可以在因为某些原因无法创建实例而返回空值，且不需要抛出异常，但是在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数中必须invoke父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数，以此来保证子类可以正确的初始化实例。&lt;/p&gt;

&lt;h3 id=&quot;new函数&quot;&gt;new函数&lt;/h3&gt;
&lt;p&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;的子类去初始化实例时还有另外一种写法，就是invoke &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;函数，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt; SomeClass *instance = [SomeClass new]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime&lt;/code&gt;中我们可以发现，&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;函数只是&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数的联合调用，和默认的构造函数并无二致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;+ (id)new {
    return [callAlloc(self, false/*checkNil*/) init];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是我们也可以联想到一些问题，那就是如果子类自定义了构造函数，并在自定义的构造函数中规定了一些能力和行为，我们这时如果使用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;函数来进行初始化工作，那么问题就出现了：&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;函数内部调用的还是&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;函数，而并不是子类自定义的构造函数，那么就会导致用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;函数生成的实例并不具备这些能力和行为，必然会导致一系列的问题产生。&lt;/p&gt;

&lt;h3 id=&quot;对象内存&quot;&gt;对象内存&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/in-post-2018/post-data-bytes.png&quot; alt=&quot;post-data-bytes&quot; /&gt;
我们初始化得到的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;对象其实是一个指针，指针指向对象实际存在的内存，在64位架构下，指针大小为8&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，所以一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;的实例对象实际大小为8&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，而在上面的源码中我们可以看到，对于小于16&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;的对象来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;Apple&lt;/code&gt;会强制分配给16&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;的内存，这就解释了为什么下面两段代码返回结果不同的原因&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSObject *objc = [[NSObject alloc] init];
NSLog(@&quot;objc对象实际需要的内存大小: %zd&quot;, class_getInstanceSize([objc class]));
NSLog(@&quot;objc对象实际分配的内存大小: %zd&quot;, malloc_size((__bridge const void *)(objc)));

//objc对象实际所需的内存大小: 8
//objc对象实际占用的内存大小: 16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其实我们可以手动推算出自定义类的内存布局的内存占用，新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSObject&lt;/code&gt;的子类&lt;code class=&quot;highlighter-rouge&quot;&gt;SomeClass&lt;/code&gt;，并转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt;代码，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@interface SomeClass: NSObject
{
    int count;
}
@end

// 转换后得到的C++代码
struct SomeClass_IMPL {
    struct NSObject_IMPL NSObject_IVARS; //isa指针
    int count;
};

struct NSObject_IMPL {
    Class isa; //指向struct objc_class结构体类型的指针
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过结构体&lt;code class=&quot;highlighter-rouge&quot;&gt;SomeClass_IMPL&lt;/code&gt;我们可以看到，该结构体有两个成员变量:一个&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针和&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;型变量，在64位架构下&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针占用8&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;型占用4&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;。所以最终结果为8+4=12&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;
，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;SomeClass&lt;/code&gt;的实例需要12&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;的内存，由于12&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;小于16&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，所以系统最后会分配给该对象16&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，然后我们对比下系统输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;SomeClass *instance = [[SomeClass alloc] init];
NSLog(@&quot;objc对象实际需要的内存大小: %zd&quot;, class_getInstanceSize([instance class]));
NSLog(@&quot;objc对象实际分配的内存大小: %zd&quot;, malloc_size((__bridge const void *)(instance)));

//objc对象理论所需的内存大小: 16
//objc对象实际占用的内存大小: 16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然而&lt;code class=&quot;highlighter-rouge&quot;&gt;class_getInstanceSize&lt;/code&gt;输出与我们预期的12&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;不符，为什么？因为字节对齐&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;字节对齐&lt;/strong&gt; :结构体大小需是最大成员变量大小的整数倍。
在结构体&lt;code class=&quot;highlighter-rouge&quot;&gt;SomeClass_IMPL&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针为最大成员变量，根据字节对齐的规则，对象所需内存为&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针内存大小的倍数，即16&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们再增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;型的成员变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@interface SomeClass: NSObject
{
    int count;
    double width;
}
@end

// 转换为C++代码
struct SomeClass_IMPL {
    //isa指针
    struct NSObject_IMPL NSObject_IVARS; 
    int count;
    double width;
};

struct NSObject_IMPL {
    //指向struct objc_class结构体类型的指针

    Class isa; 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;型在64位架构下占用8&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，12+8=20&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，由于结构体&lt;code class=&quot;highlighter-rouge&quot;&gt;SomeClass_IMPL&lt;/code&gt;中最大的成员变量为&lt;code class=&quot;highlighter-rouge&quot;&gt;isa&lt;/code&gt;指针，然后根据字节对齐规则，得出&lt;code class=&quot;highlighter-rouge&quot;&gt;SomeClass&lt;/code&gt;的实例对象所需24&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，占用内存24&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，然后来验证一下结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;SomeClass *instance = [[SomeClass alloc] init];
NSLog(@&quot;objc对象实际需要的内存大小: %zd&quot;, class_getInstanceSize([instance class]));
NSLog(@&quot;objc对象实际分配的内存大小: %zd&quot;, malloc_size((__bridge const void *)(instance)));

//objc对象理论所需的内存大小: 24
//objc对象实际占用的内存大小: 32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而系统结果还是和我们的预期不符，这又是为什么？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iOS中的&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;函数分配内存空间时，是根据&lt;code class=&quot;highlighter-rouge&quot;&gt;bucket&lt;/code&gt;来分配的。&lt;code class=&quot;highlighter-rouge&quot;&gt;bucket&lt;/code&gt;的大小是16的倍数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看出系统是按16的倍数来分配对象的内存大小的。由于24并不是16的倍数，所以系统取值32，固分配内存32&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;，这就是为什么系统输出和我们预期不符的原因。&lt;/p&gt;

&lt;h3 id=&quot;so&quot;&gt;So&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc&lt;/code&gt;函数负责分配内存并返回地址给指针，&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;则更多的关注于初始化实例的行为和能力，对象内存是根据CF Require、字节对齐、bucket等规则来分配的。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/22/Runtime(alloc+init)/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/22/Runtime(alloc+init)/</guid>
        
        <category>Runtime</category>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
      <item>
        <title>关于Paypal支付</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这几天都在调研服务端和客户端的支付行为,因为要使用Paypal用于跨境的支付&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;h2 id=&quot;选择平台&quot;&gt;选择平台&lt;/h2&gt;

&lt;p&gt;打开&lt;a href=&quot;https://developer.paypal.com/docs/integration/mobile/ios-integration-guide/&quot;&gt;Paypal开发者&lt;/a&gt;网站,映入眼帘的是&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/in-post-2018/post-paypal-warning.png&quot; alt=&quot;post-paypal-warning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;什么意思呢？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Paypal的意思是，如果有任何高级功能(如直接信用卡流程)不被批准用于新的集成。如果你在SDK被弃用之前已经集成，你仍然可以使用，但是PayPal不鼓励任何新的集成。Paypal建议接入BrainTree和Express checkout。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么是&lt;a href=&quot;https://www.braintreepayments.com&quot;&gt;BrainTree&lt;/a&gt;?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Paypal旗下的聚合支付方式,包含很多种支付方式(Paypal、信用卡、Apple Pay…)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么是&lt;a href=&quot;https://developer.paypal.com/docs/checkout/&quot;&gt;Express checkout&lt;/a&gt;?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Webview中的Paypal支付方式，订单支付在客户端完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;我对比了一下这三种方式,最后决定使用原生的SDK,原因如下&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;后端已经为Web提前接入了原生的SDK，如果要切换到BrainTree，需要增加额外的代码。&lt;/li&gt;
  &lt;li&gt;BrainTree比较重，相对于原生的SDK。&lt;/li&gt;
  &lt;li&gt;Express checkout界面风格和我们的App风格差距太大，需要自定义。&lt;/li&gt;
  &lt;li&gt;我们需要原生的体验,基于HTML的操作行为，体验不太好。&lt;/li&gt;
  &lt;li&gt;虽然官方不推荐使用SDK，但我觉得原因主要是推广BrainTree。&lt;/li&gt;
  &lt;li&gt;我们目前不使用Paypal信用卡支付。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;虽然原生SDK的文档说明很模糊，甚至可以说过时，但是有了上面的理由，并不能阻止我使用它。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;接入&quot;&gt;接入&lt;/h2&gt;

&lt;h3 id=&quot;支付行为选择&quot;&gt;支付行为选择&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Paypal的原生SDK中有两种支付行为&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Single Payment。&lt;/li&gt;
  &lt;li&gt;Future Payments。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;由于Single Payment的支付行为在客户端,所以被我们弃用。Future Payments的支付行为只需要用户在客户端完成授权，之后的支付行为完全由后端代理。所以最后我们选择了后者。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;支付流程&quot;&gt;支付流程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;需要去官网&lt;a href=&quot;https://www.paypal.com/signin?returnUri=https%3A%2F%2Fdeveloper.paypal.com%2Fdeveloper%2Fapplications&quot;&gt;注册&lt;/a&gt;App和沙箱账号，申请步骤和流程很清晰。主要是支付流程比较复杂，支付流程总结如下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;→ 客户端申请Future Payments权限&lt;br /&gt;
 → 用户登录(用户手动登录Paypal)&lt;br /&gt;
 → 用户同意协议，并授权&lt;br /&gt;
 → 授权成功后客户端回调得到授权码&lt;br /&gt;
 → 客户端上传授权码给后端&lt;br /&gt;
 → 后端拿到授权码去申请token&lt;br /&gt;
 → 后端得到token后，使用token创建订单&lt;br /&gt;
 → 创建订单成功后得到Paypal生成的Authorization Id(字段名id)&lt;br /&gt;
 → 使用id去捕获订单&lt;br /&gt;
 → 扣款成功，完成支付&lt;br /&gt;
 → 通知客户端支付结果&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;客户端文档 &lt;a href=&quot;https://github.com/paypal/PayPal-iOS-SDK/blob/master/docs/future_payments_mobile.md&quot;&gt;iOS开发文档&lt;/a&gt;、&lt;a href=&quot;https://github.com/paypal/PayPal-Android-SDK/blob/master/docs/future_payments_mobile.md&quot;&gt;Android开发文档&lt;/a&gt;，移动端平台的接入步骤大致相同。&lt;/strong&gt;
&lt;strong&gt;服务端文档 &lt;a href=&quot;https://github.com/paypal/PayPal-Android-SDK/blob/master/docs/future_payments_server.md&quot;&gt;Curl示例&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/11/Paypal(Server+Client)/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/11/Paypal(Server+Client)/</guid>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        <category>Paypal</category>
        
        <category>BrainTree</category>
        
        <category>Server</category>
        
        <category>Service</category>
        
        
      </item>
    
      <item>
        <title>AFNetWorking是如何进行数据缓存的?</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;16年翻译的一篇关于AFNetWorking的文章，现在从Github搬运了过来&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.originate.com/blog/2014/02/20/afimagecache-vs-nsurlcache/&quot;&gt;原文－Tim Brandt《How Does Caching Work in AFNetworking? : AFImageCache &amp;amp; NSUrlCache Explained》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;p&gt;  如果你是一个正在使用由&lt;a href=&quot;https://github.com/mattt&quot;&gt;Matt Thompson&lt;/a&gt;开发的网络库 &lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetWorking&lt;/code&gt;(如果你还没有使用,那你还在等什么?)的iOS开发者,也许你一直很好奇和困惑它的缓存机制,并且想要了解如何更好地充分利用它?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;实际上利用了两套单独的缓存机制:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImagecache&lt;/code&gt; : 继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;的图片内存缓存的类.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;   : &lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;的默认缓存机制,用于存储&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLResponse&lt;/code&gt;对象:一个默认缓存在内存,并且可以通过一些配置操作可以持久缓存到磁盘的类.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;afimagecache是如何工作的&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;是如何工作的?&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;属于&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView+AFNetworking&lt;/code&gt;的一部分,继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;,以URL(从&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequest&lt;/code&gt;对象中获取)字符串作为key值来存储&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象.
&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;的定义如下:(这里我们声明了一个2M内存和100M磁盘空间的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;对象.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@interface AFImageCache : NSCache &amp;lt;AFImageCache&amp;gt;

// singleton instantiation :

+ (id &amp;lt;AFImageCache&amp;gt;)sharedImageCache {
    static AFImageCache *_af_defaultImageCache = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&amp;amp;oncePredicate, ^{
        _af_defaultImageCache = [[AFImageCache alloc] init];

// clears out cache on memory warning :

    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidReceiveMemoryWarningNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * __unused notification) {
        [_af_defaultImageCache removeAllObjects];
    }];
});

// key from [[NSURLRequest URL] absoluteString] :

static inline NSString * AFImageCacheKeyFromURLRequest(NSURLRequest *request) {
    return [[request URL] absoluteString];
}

@implementation AFImageCache

// write to cache if proper policy on NSURLRequest :

- (UIImage *)cachedImageForRequest:(NSURLRequest *)request {
    switch ([request cachePolicy]) {
        case NSURLRequestReloadIgnoringCacheData:
        case NSURLRequestReloadIgnoringLocalAndRemoteCacheData:
            return nil;
        default:
            break;
    }

    return [self objectForKey:AFImageCacheKeyFromURLRequest(request)];
}

// read from cache :

- (void)cacheImage:(UIImage *)image
        forRequest:(NSURLRequest *)request {
    if (image &amp;amp;&amp;amp; request) {
        [self setObject:image forKey:AFImageCacheKeyFromURLRequest(request)];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;的私有实现,它把所有可访问的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象存入&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;中,并控制着&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象应该在何时释放,如果&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象释放的时候你希望去做一些监听操作,你可以实现&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCacheDelegate&lt;/code&gt;的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cache:willEvictObject&lt;/code&gt; 代理方法.&lt;a href=&quot;https://github.com/mattt&quot;&gt;Matt Thompson&lt;/a&gt;已经谦虚的告诉我在AFNetworking2.1版本中可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setSharedImageCache&lt;/code&gt;方法来配置&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;，&lt;a href=&quot;http://cocoadocs.org/docsets/AFNetworking/2.2.1/Categories/UIImageView+AFNetworking.html#//api/name/setSharedImageCache&quot;&gt;这里&lt;/a&gt;是 AFN2.2.1中的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView+AFNetworking&lt;/code&gt;文档.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;nsurlcache&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;,它利用了iOS原生的缓存机制,并且&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;缓存了服务器返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRespone&lt;/code&gt;对象.&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;shareCache&lt;/code&gt;方法是默认开启的,你可以利用它来获取每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;对象的URL内容.让人不爽的是,它的默认配置是缓存到内存而且并没有写入到磁盘.为了tame the beast(驯服野兽？不太懂),增加可持续性,你可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate&lt;/code&gt;中简单地声明一个共享的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;对象,像这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:2 * 1024 * 1024
                                              diskCapacity:100 * 1024 * 1024
                                              diskPath:nil];
[NSURLCache setSharedURLCache:sharedCache];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;设置nsurlrequest对象的缓存策略&quot;&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequest&lt;/code&gt;对象的缓存策略&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt; 将对每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequest&lt;/code&gt;对象遵守缓存策略(&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequestCachePolicy&lt;/code&gt;)，策略如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt; NSURLRequestUseProtocolCachePolicy                //默认的缓存策略，对特定的URL请求使用网络协议中实现的缓存逻辑
 NSURLRequestReloadIgnoringLocalCacheData          //忽略本地缓存，重新请请求
 NSURLRequestReloadIgnoringLocalAndRemoteCacheData //忽略本地和远程缓存，重新请求
 NSURLRequestReturnCacheDataElseLoad               //有缓存则从中加载，如果没有则去请求
 NSURLRequestReturnCacheDataDontLoad               //无网络状态下不去请求，一直加载本地缓存数据无论其是否存在
 NSURLRequestReloadRevalidatingCacheData           //默从原始地址确认缓存数据的合法性之后，缓存数据才可使用，否则请求原始地址
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;用nsurlcache缓存数据到磁盘&quot;&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;缓存数据到磁盘&lt;/h5&gt;

&lt;h6 id=&quot;cache-control-http-header&quot;&gt;Cache-Control HTTP Header&lt;/h6&gt;
&lt;p&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Controlheader&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires header&lt;/code&gt;存在于服务器返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP response header&lt;/code&gt;中,来用于客户端的缓存工作(前者优先级要高于后者),这里面有很多地方需要注意,&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;可以拥有被定义为类似&lt;code class=&quot;highlighter-rouge&quot;&gt;max-age&lt;/code&gt;的参数（在更新响应之前要缓存多长时间), public/private 访问或者是&lt;code class=&quot;highlighter-rouge&quot;&gt;non－cache&lt;/code&gt;(不缓存响应数据),&lt;a href=&quot;http://dev.mobify.com/blog/beginners-guide-to-http-cache-headers/&quot;&gt;这里&lt;/a&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP cache headers&lt;/code&gt;进行了很好的介绍.&lt;/p&gt;

&lt;h6 id=&quot;继承并控制nsurlcache&quot;&gt;继承并控制&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;如果你想跳过&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;,并且想要自己来制定规则读写一个带有&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLResponse&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;,你可以继承&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;.下面有个例子,使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CACHE_EXPIRES&lt;/code&gt;来判断在获取源数据之前对缓存数据保留多长时间.(感谢 Mattt Thompson的&lt;a href=&quot;https://twitter.com/mattt/status/444538735838134272&quot;&gt;回复&lt;/a&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt; @interface CustomURLCache : NSURLCache

static NSString * const CustomURLCacheExpirationKey = @&quot;CustomURLCacheExpiration&quot;;
static NSTimeInterval const CustomURLCacheExpirationInterval = 600;

@implementation CustomURLCache

+ (instancetype)standardURLCache {
    static CustomURLCache *_standardURLCache = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        _standardURLCache = [[CustomURLCache alloc]
                                 initWithMemoryCapacity:(2 * 1024 * 1024)
                                 diskCapacity:(100 * 1024 * 1024)
                                 diskPath:nil];
    }

    return _standardURLCache;
}

#pragma mark - NSURLCache

- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request {
    NSCachedURLResponse *cachedResponse = [super cachedResponseForRequest:request];

    if (cachedResponse) {
        NSDate* cacheDate = cachedResponse.userInfo[CustomURLCacheExpirationKey];
        NSDate* cacheExpirationDate = [cacheDate dateByAddingTimeInterval:CustomURLCacheExpirationInterval];
        if ([cacheExpirationDate compare:[NSDate date]] == NSOrderedAscending) {
            [self removeCachedResponseForRequest:request];
            return nil;
        }
    }
}

    return cachedResponse;
}

- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse
                 forRequest:(NSURLRequest *)request
{
    NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithDictionary:cachedResponse.userInfo];
    userInfo[CustomURLCacheExpirationKey] = [NSDate date];

    NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:cachedResponse.response data:cachedResponse.data userInfo:userInfo storagePolicy:cachedResponse.storagePolicy];

    [super storeCachedResponse:modifiedCachedResponse forRequest:request];
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在你有了属于自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;的子类,不要忘了在&lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate&lt;/code&gt;中初始化并且使用它.&lt;/p&gt;

&lt;h6 id=&quot;在缓存之前重写nsurlresponse&quot;&gt;在缓存之前重写&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLResponse&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-connection:willCacheResponse&lt;/code&gt; 代理方法是在被缓存之前用于截断和编辑由&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCacheResponse&lt;/code&gt;的地方.
对&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCacheResponse&lt;/code&gt;进行处理并返回一个可变的拷贝对象(代码来自&lt;a href=&quot;http://nshipster.com/nsurlcache/&quot;&gt;NSHipster blog&lt;/a&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (NSCachedURLResponse *)connection:(NSURLConnection *)connection
                  willCacheResponse:(NSCachedURLResponse *)cachedResponse {
    NSMutableDictionary *mutableUserInfo = [[cachedResponse userInfo] mutableCopy];
    NSMutableData *mutableData = [[cachedResponse data] mutableCopy];
    NSURLCacheStoragePolicy storagePolicy = NSURLCacheStorageAllowedInMemoryOnly;

    // ...

    return [[NSCachedURLResponse alloc] initWithResponse:[cachedResponse response]
                                                    data:mutableData
                                                userInfo:mutableUserInfo
                                           storagePolicy:storagePolicy];
}

// If you do not wish to cache the NSURLCachedResponse, just return nil from the delegate function:

- (NSCachedURLResponse *)connection:(NSURLConnection *)connection
                  willCacheResponse:(NSCachedURLResponse *)cachedResponse {
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&quot;禁用nsurlcache&quot;&gt;禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;不想使用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;? 不为所动? 好吧,你可以禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;,只需要将内存和磁盘空间设置为0就行了.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:0
                                              diskCapacity:0
                                              diskPath:nil];
[NSURLCache setSharedURLCache:sharedCache];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;我写这篇博客的目的是为iOS社区贡献绵薄之力,并总结了我是如何来处理关于&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;缓存问题的.我们有个内部App在加载了大量图片后,出现了内存和性能问题,而我的主要职责是诊断这个App的缓存行为,在研究过程中,我在网上搜索了很多资料并且做了很多调试,在我汇总之后就写到了这篇博客中,我希望这篇文章可以为开发者使用&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;时提供一些帮助,真心希望对你们有用!&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/30/AFNetworking/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/30/AFNetworking/</guid>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        <category>AFNetWorking</category>
        
        <category>Network</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Jackcao Blog</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;在2018年的尾巴上，我开通了这个Blog。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一直想拥有一个属于自己的空间去记录学习，记录生活，却由于种种原因并没有去真正的实践起来。&lt;/p&gt;

&lt;p&gt;我这几年里也尝试过&lt;a href=&quot;https://www.jianshu.com&quot;&gt;简书&lt;/a&gt;，&lt;a href=&quot;https://github.com&quot;&gt;Github&lt;/a&gt;等等，这几个平台虽然并没有像&lt;a href=&quot;https://www.csdn.net&quot;&gt;CSDN&lt;/a&gt;那样凌乱不堪，不过我总有一种寄人篱下的感觉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开通Blog的初衷更多的是督促自己,就像写日记一样:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;研究工作中使用到的各种技术&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展工作中碰到的技术&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;撰写工作感悟&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总结经验技巧&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读书笔记&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记录生活&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;h5 id=&quot;从0到1&quot;&gt;从0到1&lt;/h5&gt;

&lt;p&gt;最近也比较忙，没有太多时间去做，算下来断断续续搭建这个网站大概用了三天时间。之前因为兴趣也做过服务器，了解过网站搭建流程，所以在这个过程中并没有碰到问题。BTW:&lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll&lt;/code&gt;是个很强大的工具！&lt;/p&gt;

&lt;!-- ##### 域名

很多朋友问我为什么不叫`Jackcao.ml`，因为我的外国朋友一直称呼我为Jackchao，我也就听习惯了。申请域名的时候，突发奇想觉得把这个用作域名比较好。虽然我现在想改，但也改不掉了…… --&gt;

&lt;h5 id=&quot;服务&quot;&gt;服务&lt;/h5&gt;

&lt;p&gt;服务部署在&lt;code class=&quot;highlighter-rouge&quot;&gt;Github Pages&lt;/code&gt;下面，国内访问的话会慢一点，不过毕竟这是免费的空间🤷‍♂️。&lt;/p&gt;

&lt;h5 id=&quot;前端&quot;&gt;前端&lt;/h5&gt;

&lt;p&gt;我并不擅长做前端，所以目前的页面是用的是一套模版，然后经过我的修改生成的，模版作者叫做&lt;a href=&quot;https://github.com/huxpro&quot;&gt;Hux&lt;/a&gt;，感谢🙏&lt;/p&gt;

&lt;h5 id=&quot;读写&quot;&gt;读写&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;Markdown是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;text-align: right; color:gray; font-style:italic&quot;&gt; 
  &lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;-- 摘自维基百科 &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;而且&lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll&lt;/code&gt;自带&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;解析器，直接把&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;文本转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt;，语法还要多学习。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;今年下半年换了份新工作，到现在这半年来经历了很多事，而且愈发迷茫起来，渐渐地认识到自己有很多不足之处却没办法一下子改变，尤其是在国内这种大环境下，变的很浮躁，渐渐地对自己之前的人生规划抱有怀疑的态度。入了程序员这行，你就要不停地去学习，不停地去思考，去提高自己，不能让自己陷入舒适区，舒适区呆久了，人也就废了。现在我把心静下来了，突然发现目标很清晰，兜兜转转还是觉得需要提高一下自己的人生上限，我还很年轻，我还想去做一下”无谓”的”挣扎”。也有过其他想法，但是现在我觉得做好当下最重要，以后的事就让它随波逐流吧。这个博客会一直记录自己的学习和生活，记录一些学习上的总结，记录自己经历的事，也算是监督和敦促自己，希望自己会坚持下去。&lt;/p&gt;

&lt;p&gt;👋👋&lt;/p&gt;

&lt;p&gt;—— Jackcao 后记于 2018.11.29&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/29/hello-2018/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/29/hello-2018/</guid>
        
        <category>生活</category>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
  </channel>
</rss>
