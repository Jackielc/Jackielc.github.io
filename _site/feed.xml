<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jackcao</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 11 Dec 2018 17:27:58 +0800</pubDate>
    <lastBuildDate>Tue, 11 Dec 2018 17:27:58 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>关于Paypal支付</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;最近要使用Paypal用于跨境的支付,这几天都在调研服务端和客户端的支付行为,在这个过程中过程中遇到了很多的问题,特此记录&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;h2 id=&quot;选择平台&quot;&gt;选择平台&lt;/h2&gt;

&lt;p&gt;打开&lt;a href=&quot;https://developer.paypal.com/docs/integration/mobile/ios-integration-guide/&quot;&gt;Paypal开发者&lt;/a&gt;网站,映入眼帘的是&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/in-post-201811/post-paypal-warning.png&quot; alt=&quot;post-paypal-warning&quot; /&gt;&lt;/p&gt;

&lt;p&gt;什么意思呢？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Paypal的意思是,对于新的接入官方不太推荐你去接入原生的SDK,建议接入BrainTree和Express checkout,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么是&lt;a href=&quot;https://www.braintreepayments.com&quot;&gt;BrainTree&lt;/a&gt;?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Paypal旗下的聚合支付方式,包含很多种支付方式(Paypal、信用卡、Apple Pay…)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么是&lt;a href=&quot;https://developer.paypal.com/docs/checkout/&quot;&gt;Express checkout&lt;/a&gt;?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;镶嵌在Webview中的Paypal支付方式,订单支付在客户端完成&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;我对比了一下这三种方式,最后决定使用原生的SDK,原因如下&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;后端已经为Web提前接入了原生的SDK,如果要切换到BrainTree,需要增加额外的代码。&lt;/li&gt;
  &lt;li&gt;BrainTree比较重，相对于原生的SDK。&lt;/li&gt;
  &lt;li&gt;Express checkout界面风格和我们的App风格差距太大，需要自定义。&lt;/li&gt;
  &lt;li&gt;我们需要原生的体验,基于HTML的操作行为,体验不太好。&lt;/li&gt;
  &lt;li&gt;虽然官方不推荐使用SDK，我觉得原因主要是要推广BrainTree。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;虽然原生SDK的文档说明很模糊，甚至可以说过时，但是有了上面的理由，并不能阻止我们使用它。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;接入&quot;&gt;接入&lt;/h2&gt;

&lt;h3 id=&quot;支付行为选择&quot;&gt;支付行为选择&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Paypal的原生SDK中有两种支付行为&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Single Payment。&lt;/li&gt;
  &lt;li&gt;Future Payments。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;由于Single Payment的支付行为在客户端,所以被我们弃用。Future Payments的支付行为只需要用户在客户端完成授权,之后的支付行为完全由后端代理。所以最后我们选择了后者&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;支付流程&quot;&gt;支付流程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;需要去官网&lt;a href=&quot;https://www.paypal.com/signin?returnUri=https%3A%2F%2Fdeveloper.paypal.com%2Fdeveloper%2Fapplications&quot;&gt;注册&lt;/a&gt;App和沙箱账号，申请步骤和流程很清晰。主要是支付流程比较复杂，支付流程总结如下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;→ 客户端申请Future Payments权限&lt;br /&gt;
 → 用户登录(用户手动登录Paypal)&lt;br /&gt;
 → 用户同意协议，并授权&lt;br /&gt;
 → 授权成功后客户端回调得到授权码&lt;br /&gt;
 → 客户端上传授权码给后端&lt;br /&gt;
 → 后端拿到授权码去申请token&lt;br /&gt;
 → 后端得到token后，使用token创建订单&lt;br /&gt;
 → 创建订单成功后得到Paypal生成的Authorization Id(字段名id)&lt;br /&gt;
 → 使用id去捕获订单&lt;br /&gt;
 → 扣款成功，完成支付&lt;br /&gt;
 → 通知客户端支付结果&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;客户端文档 &lt;a href=&quot;https://github.com/paypal/PayPal-iOS-SDK/blob/master/docs/future_payments_mobile.md&quot;&gt;iOS开发文档&lt;/a&gt;、&lt;a href=&quot;https://github.com/paypal/PayPal-Android-SDK/blob/master/docs/future_payments_mobile.md&quot;&gt;Android开发文档&lt;/a&gt;,移动端平台的接入步骤大致相同.&lt;/strong&gt;
&lt;strong&gt;服务端文档 &lt;a href=&quot;https://github.com/paypal/PayPal-Android-SDK/blob/master/docs/future_payments_server.md&quot;&gt;Curl示例&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/11/Paypal(Server+Client)/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/11/Paypal(Server+Client)/</guid>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        <category>Paypal</category>
        
        <category>BrainTree</category>
        
        <category>Server</category>
        
        <category>Service</category>
        
        
      </item>
    
      <item>
        <title>AFNetWorking是如何进行数据缓存的?</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;16年翻译的一篇关于AFNetWorking的文章，现在从Github搬运了过来&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://blog.originate.com/blog/2014/02/20/afimagecache-vs-nsurlcache/&quot;&gt;原文－Tim Brandt《How Does Caching Work in AFNetworking? : AFImageCache &amp;amp; NSUrlCache Explained》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;p&gt;  如果你是一个正在使用由&lt;a href=&quot;https://github.com/mattt&quot;&gt;Matt Thompson&lt;/a&gt;开发的网络库 &lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetWorking&lt;/code&gt;(如果你还没有使用,那你还在等什么?)的iOS开发者,也许你一直很好奇和困惑它的缓存机制,并且想要了解如何更好地充分利用它?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;实际上利用了两套单独的缓存机制:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImagecache&lt;/code&gt; : 继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;的图片内存缓存的类.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;   : &lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;的默认缓存机制,用于存储&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLResponse&lt;/code&gt;对象:一个默认缓存在内存,并且可以通过一些配置操作可以持久缓存到磁盘的类.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;afimagecache是如何工作的&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;是如何工作的?&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;属于&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView+AFNetworking&lt;/code&gt;的一部分,继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;,以URL(从&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequest&lt;/code&gt;对象中获取)字符串作为key值来存储&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象.
&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;的定义如下:(这里我们声明了一个2M内存和100M磁盘空间的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;对象.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;@interface AFImageCache : NSCache &amp;lt;AFImageCache&amp;gt;

// singleton instantiation :

+ (id &amp;lt;AFImageCache&amp;gt;)sharedImageCache {
    static AFImageCache *_af_defaultImageCache = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&amp;amp;oncePredicate, ^{
        _af_defaultImageCache = [[AFImageCache alloc] init];

// clears out cache on memory warning :

    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidReceiveMemoryWarningNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * __unused notification) {
        [_af_defaultImageCache removeAllObjects];
    }];
});

// key from [[NSURLRequest URL] absoluteString] :

static inline NSString * AFImageCacheKeyFromURLRequest(NSURLRequest *request) {
    return [[request URL] absoluteString];
}

@implementation AFImageCache

// write to cache if proper policy on NSURLRequest :

- (UIImage *)cachedImageForRequest:(NSURLRequest *)request {
    switch ([request cachePolicy]) {
        case NSURLRequestReloadIgnoringCacheData:
        case NSURLRequestReloadIgnoringLocalAndRemoteCacheData:
            return nil;
        default:
            break;
    }

    return [self objectForKey:AFImageCacheKeyFromURLRequest(request)];
}

// read from cache :

- (void)cacheImage:(UIImage *)image
        forRequest:(NSURLRequest *)request {
    if (image &amp;amp;&amp;amp; request) {
        [self setObject:image forKey:AFImageCacheKeyFromURLRequest(request)];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;的私有实现,它把所有可访问的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象存入&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCache&lt;/code&gt;中,并控制着&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象应该在何时释放,如果&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImage&lt;/code&gt;对象释放的时候你希望去做一些监听操作,你可以实现&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCacheDelegate&lt;/code&gt;的 &lt;code class=&quot;highlighter-rouge&quot;&gt;cache:willEvictObject&lt;/code&gt; 代理方法.&lt;a href=&quot;https://github.com/mattt&quot;&gt;Matt Thompson&lt;/a&gt;已经谦虚的告诉我在AFNetworking2.1版本中可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setSharedImageCache&lt;/code&gt;方法来配置&lt;code class=&quot;highlighter-rouge&quot;&gt;AFImageCache&lt;/code&gt;，&lt;a href=&quot;http://cocoadocs.org/docsets/AFNetworking/2.2.1/Categories/UIImageView+AFNetworking.html#//api/name/setSharedImageCache&quot;&gt;这里&lt;/a&gt;是 AFN2.2.1中的&lt;code class=&quot;highlighter-rouge&quot;&gt;UIImageView+AFNetworking&lt;/code&gt;文档.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;nsurlcache&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;,它利用了iOS原生的缓存机制,并且&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;缓存了服务器返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRespone&lt;/code&gt;对象.&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;shareCache&lt;/code&gt;方法是默认开启的,你可以利用它来获取每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;对象的URL内容.让人不爽的是,它的默认配置是缓存到内存而且并没有写入到磁盘.为了tame the beast(驯服野兽？不太懂),增加可持续性,你可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate&lt;/code&gt;中简单地声明一个共享的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;对象,像这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:2 * 1024 * 1024
                                              diskCapacity:100 * 1024 * 1024
                                              diskPath:nil];
[NSURLCache setSharedURLCache:sharedCache];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;设置nsurlrequest对象的缓存策略&quot;&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequest&lt;/code&gt;对象的缓存策略&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt; 将对每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequest&lt;/code&gt;对象遵守缓存策略(&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLRequestCachePolicy&lt;/code&gt;)，策略如下所示:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt; NSURLRequestUseProtocolCachePolicy                //默认的缓存策略，对特定的URL请求使用网络协议中实现的缓存逻辑
 NSURLRequestReloadIgnoringLocalCacheData          //忽略本地缓存，重新请请求
 NSURLRequestReloadIgnoringLocalAndRemoteCacheData //忽略本地和远程缓存，重新请求
 NSURLRequestReturnCacheDataElseLoad               //有缓存则从中加载，如果没有则去请求
 NSURLRequestReturnCacheDataDontLoad               //无网络状态下不去请求，一直加载本地缓存数据无论其是否存在
 NSURLRequestReloadRevalidatingCacheData           //默从原始地址确认缓存数据的合法性之后，缓存数据才可使用，否则请求原始地址
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;用nsurlcache缓存数据到磁盘&quot;&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;缓存数据到磁盘&lt;/h5&gt;

&lt;h6 id=&quot;cache-control-http-header&quot;&gt;Cache-Control HTTP Header&lt;/h6&gt;
&lt;p&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Controlheader&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Expires header&lt;/code&gt;存在于服务器返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP response header&lt;/code&gt;中,来用于客户端的缓存工作(前者优先级要高于后者),这里面有很多地方需要注意,&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;可以拥有被定义为类似&lt;code class=&quot;highlighter-rouge&quot;&gt;max-age&lt;/code&gt;的参数（在更新响应之前要缓存多长时间), public/private 访问或者是&lt;code class=&quot;highlighter-rouge&quot;&gt;non－cache&lt;/code&gt;(不缓存响应数据),&lt;a href=&quot;http://dev.mobify.com/blog/beginners-guide-to-http-cache-headers/&quot;&gt;这里&lt;/a&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP cache headers&lt;/code&gt;进行了很好的介绍.&lt;/p&gt;

&lt;h6 id=&quot;继承并控制nsurlcache&quot;&gt;继承并控制&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;如果你想跳过&lt;code class=&quot;highlighter-rouge&quot;&gt;Cache-Control&lt;/code&gt;,并且想要自己来制定规则读写一个带有&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLResponse&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;,你可以继承&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;.下面有个例子,使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CACHE_EXPIRES&lt;/code&gt;来判断在获取源数据之前对缓存数据保留多长时间.(感谢 Mattt Thompson的&lt;a href=&quot;https://twitter.com/mattt/status/444538735838134272&quot;&gt;回复&lt;/a&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt; @interface CustomURLCache : NSURLCache

static NSString * const CustomURLCacheExpirationKey = @&quot;CustomURLCacheExpiration&quot;;
static NSTimeInterval const CustomURLCacheExpirationInterval = 600;

@implementation CustomURLCache

+ (instancetype)standardURLCache {
    static CustomURLCache *_standardURLCache = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        _standardURLCache = [[CustomURLCache alloc]
                                 initWithMemoryCapacity:(2 * 1024 * 1024)
                                 diskCapacity:(100 * 1024 * 1024)
                                 diskPath:nil];
    }

    return _standardURLCache;
}

#pragma mark - NSURLCache

- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request {
    NSCachedURLResponse *cachedResponse = [super cachedResponseForRequest:request];

    if (cachedResponse) {
        NSDate* cacheDate = cachedResponse.userInfo[CustomURLCacheExpirationKey];
        NSDate* cacheExpirationDate = [cacheDate dateByAddingTimeInterval:CustomURLCacheExpirationInterval];
        if ([cacheExpirationDate compare:[NSDate date]] == NSOrderedAscending) {
            [self removeCachedResponseForRequest:request];
            return nil;
        }
    }
}

    return cachedResponse;
}

- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse
                 forRequest:(NSURLRequest *)request
{
    NSMutableDictionary *userInfo = [NSMutableDictionary dictionaryWithDictionary:cachedResponse.userInfo];
    userInfo[CustomURLCacheExpirationKey] = [NSDate date];

    NSCachedURLResponse *modifiedCachedResponse = [[NSCachedURLResponse alloc] initWithResponse:cachedResponse.response data:cachedResponse.data userInfo:userInfo storagePolicy:cachedResponse.storagePolicy];

    [super storeCachedResponse:modifiedCachedResponse forRequest:request];
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在你有了属于自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;的子类,不要忘了在&lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate&lt;/code&gt;中初始化并且使用它.&lt;/p&gt;

&lt;h6 id=&quot;在缓存之前重写nsurlresponse&quot;&gt;在缓存之前重写&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLResponse&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-connection:willCacheResponse&lt;/code&gt; 代理方法是在被缓存之前用于截断和编辑由&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLConnection&lt;/code&gt;创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCacheResponse&lt;/code&gt;的地方.
对&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCacheResponse&lt;/code&gt;进行处理并返回一个可变的拷贝对象(代码来自&lt;a href=&quot;http://nshipster.com/nsurlcache/&quot;&gt;NSHipster blog&lt;/a&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;- (NSCachedURLResponse *)connection:(NSURLConnection *)connection
                  willCacheResponse:(NSCachedURLResponse *)cachedResponse {
    NSMutableDictionary *mutableUserInfo = [[cachedResponse userInfo] mutableCopy];
    NSMutableData *mutableData = [[cachedResponse data] mutableCopy];
    NSURLCacheStoragePolicy storagePolicy = NSURLCacheStorageAllowedInMemoryOnly;

    // ...

    return [[NSCachedURLResponse alloc] initWithResponse:[cachedResponse response]
                                                    data:mutableData
                                                userInfo:mutableUserInfo
                                           storagePolicy:storagePolicy];
}

// If you do not wish to cache the NSURLCachedResponse, just return nil from the delegate function:

- (NSCachedURLResponse *)connection:(NSURLConnection *)connection
                  willCacheResponse:(NSCachedURLResponse *)cachedResponse {
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&quot;禁用nsurlcache&quot;&gt;禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;&lt;/h6&gt;
&lt;p&gt;不想使用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;? 不为所动? 好吧,你可以禁用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLCache&lt;/code&gt;,只需要将内存和磁盘空间设置为0就行了.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:0
                                              diskCapacity:0
                                              diskPath:nil];
[NSURLCache setSharedURLCache:sharedCache];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;我写这篇博客的目的是为iOS社区贡献绵薄之力,并总结了我是如何来处理关于&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;缓存问题的.我们有个内部App在加载了大量图片后,出现了内存和性能问题,而我的主要职责是诊断这个App的缓存行为,在研究过程中,我在网上搜索了很多资料并且做了很多调试,在我汇总之后就写到了这篇博客中,我希望这篇文章可以为开发者使用&lt;code class=&quot;highlighter-rouge&quot;&gt;AFNetworking&lt;/code&gt;时提供一些帮助,真心希望对你们有用!&lt;/p&gt;

</description>
        <pubDate>Fri, 30 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/30/AFNetworking/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/30/AFNetworking/</guid>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        <category>AFNetWorking</category>
        
        <category>Network</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Jackcao Blog</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;在2018年的尾巴上，我开通了这个Blog。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一直想拥有一个属于自己的空间去记录学习，记录生活，却由于种种原因并没有去真正的实践起来。&lt;/p&gt;

&lt;p&gt;我这几年里也尝试过&lt;a href=&quot;https://www.jianshu.com&quot;&gt;简书&lt;/a&gt;，&lt;a href=&quot;https://github.com&quot;&gt;Github&lt;/a&gt;等等，这几个平台虽然并没有像&lt;a href=&quot;https://www.csdn.net&quot;&gt;CSDN&lt;/a&gt;那样凌乱不堪，不过我总有一种寄人篱下的感觉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开通Blog的初衷更多的是督促自己,就像写日记一样:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;研究工作中使用到的各种技术&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展工作中碰到的技术&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;撰写工作感悟&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总结经验技巧&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读书笔记&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记录生活&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;h5 id=&quot;从0到1&quot;&gt;从0到1&lt;/h5&gt;

&lt;p&gt;最近也比较忙，没有太多时间去做，算下来断断续续搭建这个网站大概用了三天时间。之前因为兴趣也做过服务器，了解过网站搭建流程，所以在这个过程中并没有碰到问题。BTW:&lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll&lt;/code&gt;是个很强大的工具！&lt;/p&gt;

&lt;h5 id=&quot;域名&quot;&gt;域名&lt;/h5&gt;

&lt;p&gt;很多朋友问我为什么不叫&lt;code class=&quot;highlighter-rouge&quot;&gt;Jackcao.ml&lt;/code&gt;，因为我的外国朋友一直称呼我为Jackchao，我也就听习惯了。申请域名的时候，突发奇想觉得把这个用作域名比较好。虽然我现在想改，但也改不掉了……&lt;/p&gt;

&lt;h5 id=&quot;服务&quot;&gt;服务&lt;/h5&gt;

&lt;p&gt;服务部署在&lt;code class=&quot;highlighter-rouge&quot;&gt;Github Pages&lt;/code&gt;下面，国内访问的话会慢一点，不过毕竟这是免费的空间🤷‍♂️。&lt;/p&gt;

&lt;h5 id=&quot;前端&quot;&gt;前端&lt;/h5&gt;

&lt;p&gt;我并不擅长做前端，所以目前的页面是用的是一套模版，然后经过我的修改生成的，模版作者叫做&lt;a href=&quot;https://github.com/huxpro&quot;&gt;Hux&lt;/a&gt;，感谢🙏&lt;/p&gt;

&lt;h5 id=&quot;读写&quot;&gt;读写&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;Markdown是一种轻量级标记语言，它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，目前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;text-align: right; color:gray; font-style:italic&quot;&gt; 
  &lt;a href=&quot;http://www.w3school.com.cn&quot;&gt;-- 摘自维基百科 &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;而且&lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll&lt;/code&gt;自带&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;解析器，直接把&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;文本转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;HTML&lt;/code&gt;，语法还要多学习。&lt;/p&gt;

&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;

&lt;p&gt;今年下半年换了份新工作，到现在这半年来经历了很多事，而且愈发迷茫起来，渐渐地认识到自己有很多不足之处却没办法一下子改变，尤其是在国内这种大环境下，变的很浮躁，渐渐地对自己之前的人生规划抱有怀疑的态度。入了程序员这行，你就要不停地去学习，不停地去思考，去提高自己，不能让自己陷入舒适区，舒适区呆久了，人也就废了。现在我把心静下来了，突然发现目标很清晰，兜兜转转还是觉得需要提高一下自己的人生上限，我还很年轻，我还想去做一下”无谓”的”挣扎”。也有过其他想法，但是现在我觉得做好当下最重要，以后的事就让它随波逐流吧。这个博客会一直记录自己的学习和生活，记录一些学习上的总结，记录自己经历的事，也算是监督和敦促自己，希望自己会坚持下去。&lt;/p&gt;

&lt;p&gt;👋👋&lt;/p&gt;

&lt;p&gt;—— Jackcao 后记于 2018.11.29&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/29/hello-2018/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/29/hello-2018/</guid>
        
        <category>生活</category>
        
        <category>iOS</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
  </channel>
</rss>
